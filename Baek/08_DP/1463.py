"""
1. 아이디어
- dp[i] = 정수 i를 1로 만드는 데 필요한 최소 연산 횟수
- i에서 할 수 있는 선택은 3가지
  1) i - 1
  2) i / 2 (i가 2로 나누어질 때)
  3) i / 3 (i가 3으로 나누어질 때)
- 현재 값 i에서 가능한 이전 상태들의 dp값 중 최소값 + 1을 선택
- 1부터 n까지 순서대로 dp를 채우는 bottom-up 방식

2. 시간 복잡도
- O(n)
- 2부터 n까지 한 번씩 계산하며, 각 단계는 상수 연산만 수행

3. 자료구조
- DP 배열 dp : int[]
  - dp[i]는 i를 1로 만드는 최소 연산 횟수
  - n ≤ 1,000,000 이므로 int 배열 사용
"""

n = int(input())

dp = [0] * (n + 1)

for i in range(2, n + 1):
    # 1을 빼는 경우
    dp[i] = dp[i - 1] + 1

    # 2로 나누어지는 경우
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)

    # 3으로 나누어지는 경우
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1)

print(dp[n])
